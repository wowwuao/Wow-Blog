---
title: 2.HTTP
group:
    path: /net
    title: 计算机网络
---

## HTTP
HTTP是超文本传输协议，它作用在应用层。它定义了客户端与服务器之间交换报文的格式和方式。

使用`80`端口，使用TCP作为传输层协议，保证了数据传输的可靠性。

`明文传输`

HTTP是一个`无状态`的协议，服务器不会保存关于客户的任何信息。

HTTP有两种连接模式：
1. HTTP 1.0 以前使用的是`非持续连接`,服务器必须为每一个请求的对象建立和维护一个新的连接。可以设置`Connention:keep-alive`,要求服务器不关闭TCP连接，大多数浏览器支持同时建立`6`个持续连接。
2. HTTP 1.1 之后默认使用的都是 `持续性连接`,TCP 连接默认不关闭，可以被多个请求复用，可以避免每次建立在TCP连续三次握手的时间。

### 缺点：
1. 明文发送
2. 可能被第三方截取修改
3. 存在认证问题，第三方可以冒充他人参与通信。

## HTTP 1.1
默认都是持续性连接

### 队头堵塞
因为默认使用了持续性连接，多个请求可以复用一个TCP连接，但是在同一个TCP连接里面，数据请求的通信次序是固定的。如果前面的请求相应的特别慢的话，就会造成后续请求排队等待的情况，这种情况叫做“队头堵塞”。

当持续连接的数量达到最大时，剩余的资源需要等待其他资源请求完成后，才能发起请求。

为了解决这个问题：
1. 减少请求次数，比如雪碧图，合并脚本等
2. 并发连接，即增加持续连接的最大数量，如：
   1. 域名分片，分出多个二级域名，都指向同一个服务器。增加并发的持续连接数
## HTTP 2.0
### 1.二进制协议
报头、报尾都是二进制。统称为`“帧”`，帧的概念是它`实现多路复用的基础`。
### 2.多路复用
服务器和客户端发送的请求`不再按照顺序`，避免了队头堵塞的问题
### 3.数据流
因为HTTP 2.0 的数据包不在是按照顺序发送，所以要进行标记，指出它是属于哪个请求。

HTTP2.0 把每个请求和相应的所有数据包，成为一个数据流。每个数据流都有一个独一无二的编号。

数据包发送的时候，都必须标记数据流的ID，用来区分它属于哪个数据流。

### 4.头部压缩
由于HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以很多字段都是重复的，比如Cookie，User Agent等重复的内容，每次请求都会携带，浪费很多带宽，影响速度。

所以HTTP 2.0 把头信息，使用gzip、或者compress压缩后在发送。

另一方面，客户端和服务端同时维护一张头信息，所有字段都会存入这个表，生成一个索引号，这样只发送索引号，就能提高速度了。

### 5.服务器主动推送
HTTP 2.0 允许服务器未经请求，主动向服务器发送**`静态资源`**。

### 6.缺点
因为HTTP使用了多路复用，一般来说同一个域名下只需要一个TCP连接。由于多个数据流使用同一个TCP连接。遵守同一个流量状态控制和拥塞控制。

只要一个数据流发生堵塞，剩下的数据流就没法发出去。这就导致了后面的数据流发生堵塞。

但这个问题是TCP协议的问题，与 HTTP2.0 本身没有多大关系

## HTTP报文头
### 请求头

POST   /index.html   HTTP/1.1

请求方法   请求URL    HTTP协议与版本

Accept  请求文件类型  



## 状态码
* 1XX:信息状态码
  * **`100 Continue`** 表示继续，一般在发送post请求时，已发送了http header之后，服务端返回此信息，表示确认，之后发送具体参数信息。

* 2XX:成功状态码
  * **`200 OK`** 正常返回信息
  * **`201 Created`** 请求成功并且服务器创建了新的资源
  * **`202 Accepted`**:服务器已接受请求，但尚未处理
* 3XX:重定向
  * **`301 Moved Permanently`** 资源已永久移动，可以被浏览器缓存
  * **`302 Found`** 临时性重定向
  * **`303 See Other`** 临时性重定向，且总是使用 GET 请求新的 URL
  * **`304 Not Modified`** 自从上次请求后，请求的网页未修改过。
* 4XX:客户端错误
  * **`400 Bed Request`**：服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
  * **`401 Unauthorized`** 请求未授权，在jwt鉴权中，在未携带token的情况下，返回结果为401
  * **`403 Forbidden`** 禁止访问
  * **`404 Not Found`** 找不到与URI向匹配的资源
* 5XX:服务器错误
  * **`500 Internal Server Error`** 服务器发生未知错误
  * **`503 Service Unavailable`** 服务器端暂时无法处理请求（可能是过载或者维护）
  * **`505 HTTP Version Not Supported`** 服务器不支持请求报文使用的HTTP协议版本

  



## GET 和 POST 的区别
1. 从`缓存`的角度，GET请求会被浏览器主动缓存下来，留下历史记录，POST则默认不会。
2. 从`编码`的角度，GET只能进行URL编码，只能接受ASCLL字符，而POST没有限制。
3. 从`参数`的角度，GET一般放在URL中，因此不安全，POST放在请求体中，更适合传输敏感信息。
4. 从`幂等性`的角度，GET是幂等的，POST不是。（幂等表示执行相同的操作，结果也是相同的）
5. 从`TCP`的角度，GET请求会把报文一次性发出，而POST会分为两个TCP数据包，首先发header部分，如果服务器响应100（continue），然后发body部分（火狐浏览器除外）。

## HTTPS
### TLS握手过程
1. 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
2. 服务端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数
3. 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的 hash 值，用来提供服务器检验。
4. 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的hash值来供客户端检验。
5. 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都是用这个秘钥来加密信息。


### 如何保证安全
将对称加密的秘钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的秘钥，然后双方可以使用对称加密来进行沟通。

对于中间人问题。需要一个技术，叫数字签名。

数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。当别人把他的证书发过来的时候，再用相同的HASH算法，生成消息摘要，然后用CA的公钥对数字签名进行解密，得到CA创建的信息摘要，两者对比就知道中间有没有人篡改了。

