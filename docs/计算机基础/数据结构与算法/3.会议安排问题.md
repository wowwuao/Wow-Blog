---
title: 3.会议安排问题 
---
## 会议安排问题

每个物品都有特定的体积和价值，在容量固定时，用来装载不可分割的物品时，如何获取最大价值

### 1.会议安排问题

样例：
每个子数组为会议的`编号`、`开始时间`和`结束时间`，求如何安排会议的次数最多，依次输出会议的索引。

```js
let meetings = [[1,3,6],[2,1,4],[3,5,7] ,[4,2,5],
                [5,5,9],[6,3,8],[7,8,11],[8,6,10],
                [9,8,12],[10,12,14]]
```
核心点在于 **`最早结束（开始时间+持续时间最短），每次从剩下的会议中选择具有最早结束时间且与已安排的会议相容的会议安排`**

先根据最早结束进行排序，
```js
meetings.sort((a,b)=>{
  if(a[2]==b[2]){
    return a[1]-b[1]
  }return a[2]-b[2]
})

// meetings = 
// [  [ 2, 1, 4 ], [ 4, 2, 5 ], [ 1, 3, 6 ], [ 3, 5, 7 ],
//    [ 6, 3, 8 ], [ 5, 5, 9 ], [ 8, 6, 10 ],[ 7, 8, 11 ],
//    [ 9, 8, 12 ],[ 10, 12, 14 ]
// ]
```
#### 贪心选择过程
1. 首先选择排序后的第一个会议即最早结束的会议（编号为2），用last记录最后一个被选中会议的时间，last=4
2. 检查余下的会议，选择第一个开始时间大于等于last=4的会议，编号为3，last=7
3. 重复以上操作

```js
let meetings = [[1,3,6],[2,1,4],[3,5,7] ,[4,2,5],
                [5,5,9],[6,3,8],[7,8,11],[8,6,10],
                [9,8,12],[10,12,14]]

meetings.sort((a,b)=>{
  if(a[2]==b[2]){
    return a[1]-b[1]
  }return a[2]-b[2]
})

let last = meetings[0][2]
let res = [meetings[0]]
for(let i=1;i<meetings.length;i++){
  if(meetings[i][1]>=last){
      last = meetings[i][2]
      res.push(meetings[i])
  }
}
console.log(`最多可以安排${res.length}个会议`)
console.log("会议安排为:",res.length)
for(let v of res){
  console.log(`编号：`+`${v[0]}`.padEnd(2," ")+`,开始时间：`+`${v[1]}`.padEnd(2," ")+`,结束时间：${v[2]}`)
}


// 最多可以安排4个会议
// 会议安排为: [ [ 2, 1, 4 ], [ 3, 5, 7 ], [ 7, 8, 11 ], [ 10, 12, 
// 14 ] ]
// 编号：2 ,开始时间：1 ,结束时间：4
// 编号：3 ,开始时间：5 ,结束时间：7
// 编号：7 ,开始时间：8 ,结束时间：11
// 编号：10,开始时间：12,结束时间：14
```

